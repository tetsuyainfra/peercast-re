use std::{
    collections::HashMap,
    sync::{mpsc::channel, Arc, Mutex, RwLock},
};

use chrono::{DateTime, Utc};
use peercast_re::pcp::GnuId;
use tokio::sync::watch;
use tracing::info;

enum ChannelStatus {
    Init,
    Start(DateTime<Utc>),
    End,
    Error,
}

//------------------------------------------------------------------------------
// ChannelTrait
//
pub trait ChannelTrait: Clone + Send + Sync + 'static {
    // type InternalStore;
    type Config;
    fn new(
        root_session_id: GnuId,
        root_broadcast_id: GnuId,
        channel_id: GnuId,
        config: Self::Config,
        // status_sender: watch::Sender<ChannelStatus>, // store: Weak<Self::InternalStore>,
    ) -> Self;

    // call remove
    fn before_remove(&mut self);
}

//------------------------------------------------------------------------------
// TrackerChannel
//
#[derive(Clone)]
pub struct TrackerChannel {
    // status_sender: watch::Sender<ChannelStatus>,
}

impl std::fmt::Debug for TrackerChannel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TrackerChannel")
            // .field("store_", &self.store_)
            .field("store_", &"ChannelStoreIn{}")
            .finish()
    }
}

impl ChannelTrait for TrackerChannel {
    // type InternalStore = ChannelStoreIn<TrackerChannel>;
    type Config = TrackerChannelConfig;

    fn new(
        root_session_id: GnuId,
        root_broadcast_id: GnuId,
        channel_id: GnuId,
        config: Self::Config,
        // status_sender: watch::Sender<ChannelStatus>,
    ) -> Self {
        TrackerChannel {}
    }

    fn before_remove(&mut self) {
        todo!()
    }
}

pub struct TrackerChannelConfig {}

impl TrackerChannelConfig {
    fn new() -> Self {
        Self {}
    }
}

//------------------------------------------------------------------------------
// Internal
//
#[derive(Debug)]
struct Store<C: ChannelTrait> {
    root_session_id_: GnuId,
    root_broadcast_id_: GnuId,
    channels_: RwLock<HashMap<GnuId, Arc<C>>>,
}

impl<C: ChannelTrait> Store<C> {
    fn new(self_session_id: Option<GnuId>, self_broadcast_id: Option<GnuId>) -> Arc<Self> {
        let root_session_id_ = self_session_id.unwrap_or_else(|| GnuId::new());
        let root_broadcast_id_ = self_broadcast_id.unwrap_or_else(|| GnuId::new());

        let self_ = Self {
            root_session_id_,
            root_broadcast_id_,
            channels_: Default::default(),
        };

        let arced_self: Arc<Store<C>> = Arc::new(self_);
        StoreWatcher::start_watcher(arced_self.clone());

        arced_self
    }

    pub fn get(&self, channel_id: &GnuId) -> Option<Arc<C>> {
        self.channels_
            .read()
            .unwrap()
            .get(channel_id)
            .map(|c| c.clone())
    }

    fn get_or_create(&self, channel_id: &GnuId, config: C::Config) -> Arc<C> {
        self.get(channel_id)
            .or_else(|| {
                //
                let mut channels = self
                    .channels_
                    .write()
                    .expect("self.channels : RwLock<Store<C>> should be no lock poisons.");

                let ch = channels.entry(channel_id.clone()).or_insert_with(|| {
                    Arc::new(C::new(
                        self.root_session_id_.clone(),
                        self.root_broadcast_id_.clone(),
                        channel_id.clone(),
                        config,
                    ))
                });
                Some(ch.clone())
            })
            .unwrap()
    }
}

//------------------------------------------------------------------------------
// StoreChannelWatcher
//
struct StoreWatcher<C: ChannelTrait> {
    store_: Arc<Store<C>>,
}

impl<C: ChannelTrait> StoreWatcher<C> {
    fn start_watcher(store_: Arc<Store<C>>) {
        let watcher = Self { store_ };
        tokio::spawn(async { watcher.watcher_main().await });
    }

    async fn watcher_main(self) {
        info!("START Store's ChannelStatusWatcher");

        loop {}

        info!("FINISH Store's ChannelStatusWatcher");
    }
}

//------------------------------------------------------------------------------
// ChannelManager
//
#[derive(Debug, Clone)]
pub struct ChannelStore<C: ChannelTrait> {
    store_: Arc<Store<C>>,
}

impl<C: ChannelTrait + 'static> ChannelStore<C> {
    pub fn new(self_session_id: Option<GnuId>, self_broadcast_id: Option<GnuId>) -> Self {
        Self {
            store_: Store::new(self_session_id, self_broadcast_id),
        }
    }

    pub fn get(&self, id: &GnuId) -> Option<Arc<C>> {
        self.store_.get(id)
    }

    pub fn get_or_create(&self, id: &GnuId, config: C::Config) -> Arc<C> {
        self.store_.get_or_create(id, config)
    }
}

#[cfg(test)]
mod t {
    use std::sync::Arc;

    use peercast_re::pcp::GnuId;

    use crate::{ChannelStore, TrackerChannel, TrackerChannelConfig};

    #[test]
    fn compile_time_check() {
        fn is_sync<T: Sync>() {}
        fn is_send<T: Send>() {}
        is_sync::<ChannelStore<TrackerChannel>>();
        is_send::<ChannelStore<TrackerChannel>>();
    }

    #[tokio::test]
    async fn t() {
        let store = ChannelStore::new(None, None);
        let id = GnuId::new();
        let config = TrackerChannelConfig::new();

        let c: Arc<TrackerChannel> = store.get_or_create(&id, config);
    }
}

fn main() {}
